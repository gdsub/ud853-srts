1
00:00:00,150 --> 00:00:03,730
Great. So to move one step closer to building awesome apps like the ones you

2
00:00:03,730 --> 00:00:06,880
submitted to the discussion forum, we're going to learn about how to build up

3
00:00:06,880 --> 00:00:11,290
the Sunshine UI. We'll do a quick recap first to help remind you of the concepts

4
00:00:11,290 --> 00:00:16,940
that you learned in lesson one. In order to build a UI in Android, we use views.

5
00:00:16,940 --> 00:00:20,400
Views are rectangles on the screen, and we may or may not see the borders of

6
00:00:20,400 --> 00:00:24,890
that rectangle. Essentially, a view handles drawing and event handling. And

7
00:00:24,890 --> 00:00:29,790
all the basic widgets in Android extend from this base class. The Android design

8
00:00:29,790 --> 00:00:35,450
guide has visual examples of these basic building blocks of apps. For example,

9
00:00:35,450 --> 00:00:38,800
we have the basic text field, as well as editable text fields.

10
00:00:38,800 --> 00:00:42,970
We can do auto complete on them, and it comes with text selection as well.

11
00:00:42,970 --> 00:00:46,640
Where it pops up a contextual action bar, for you to copy and paste.

12
00:00:46,640 --> 00:00:51,840
There are also buttons, and also a suggestion to use borderless buttons.

13
00:00:51,840 --> 00:00:55,210
It also has spinners, where you can select from a drop down menu.

14
00:00:55,210 --> 00:00:58,330
There's also checkboxes, radio buttons, on/off switches, and

15
00:00:58,330 --> 00:01:02,720
they also have some progress bars. There's a ton more basic widgets here, and

16
00:01:02,720 --> 00:01:07,390
also in the Java docs. Check those out. And even ones that aren't listed here,

17
00:01:07,390 --> 00:01:10,600
so. You'll come across them as you need them.

18
00:01:10,600 --> 00:01:14,390
Now, if you want to display multiple views together, you'll need a view group.

19
00:01:14,390 --> 00:01:17,640
A view group is a container for children views. Here are a couple of

20
00:01:17,640 --> 00:01:22,030
common view groups, which Dan introduced earlier. First, we have a frame layout.

21
00:01:22,030 --> 00:01:25,230
A child that gets added will be default positioned in the top left corner of

22
00:01:25,230 --> 00:01:29,530
the view group. If you add a second view here, it will overlap the first one. So

23
00:01:29,530 --> 00:01:33,840
typically we only have one child per frame layout. Next we have a linear layout,

24
00:01:33,840 --> 00:01:37,900
it's composed of children either in a horizontal row or in a vertical column.

25
00:01:37,900 --> 00:01:41,590
We can also specify layout weight. Lay out weight allows us to

26
00:01:41,590 --> 00:01:45,410
distribute the width or height of a parent across the children. For example,

27
00:01:45,410 --> 00:01:48,940
this has weight one, and this has weight one then the width of the parent can be

28
00:01:48,940 --> 00:01:53,930
split across them evenly. Then we have a relative layout where we can specify

29
00:01:53,930 --> 00:01:58,950
that a view should be aligned to the parent's left, top, right or bottom edge.

30
00:01:58,950 --> 00:02:02,520
We can also specify that one view should be relative to another view.

31
00:02:02,520 --> 00:02:05,490
It isn't full if the space is nicely compared to a linear layout, but

32
00:02:05,490 --> 00:02:10,530
there are pros and cons to each. There's a grid layout where the views fill

33
00:02:10,530 --> 00:02:15,590
up cells in a grid. You can also have views that span multiple cells.

34
00:02:15,590 --> 00:02:18,090
I also want to point out that a view group is a view.

35
00:02:18,090 --> 00:02:21,650
So in our code when we refer to a list item layout as being a single view.

36
00:02:21,650 --> 00:02:26,050
That just means the root view of the whole view hierarchy for that layout.

37
00:02:26,050 --> 00:02:30,110
Chances are that root view is a ViewGroup, so it contains children views as well

38
00:02:30,110 --> 00:02:34,169
as ViewGroups. So basically you can nest ViewGroups within ViewGroups.

39
00:02:35,210 --> 00:02:38,510
The reason why we care so much about parent child view relationships,

40
00:02:38,510 --> 00:02:42,470
is because the way a child view gets laid out depends on its parent.

41
00:02:42,470 --> 00:02:45,500
The simplest example of this is specifying a view's width and

42
00:02:45,500 --> 00:02:48,770
height. By now you've seen that every view requires a height and

43
00:02:48,770 --> 00:02:53,529
width. The two possible values are either wrap content or match parent.

44
00:02:54,540 --> 00:02:57,860
This diagram shows all the possible combinations for width and height for

45
00:02:57,860 --> 00:03:01,620
this text view. This is the balance of the view when we set wrap_content for

46
00:03:01,620 --> 00:03:05,230
height and width. This is what happens when we do match_parent for

47
00:03:05,230 --> 00:03:09,090
the width and match_parent for the height. And this is what happens when

48
00:03:09,090 --> 00:03:12,731
both are set as match_parent. It shows the full dimensions of the parent.

49
00:03:12,731 --> 00:03:16,750
When you run this on the device. All of these would visually look the same,

50
00:03:16,750 --> 00:03:19,860
because you wouldn't see these boundaries. So why does it matter which one

51
00:03:19,860 --> 00:03:23,160
we pick? Well, it matters as soon as you have other children that need to

52
00:03:23,160 --> 00:03:27,270
be beside this view. And another reason is you want to specify gravity.

53
00:03:27,270 --> 00:03:31,250
Let me spend a quick moment explaining gravity. Say for example, you

54
00:03:31,250 --> 00:03:35,640
have this text view within a frame layout. By default, the text is left aligned.

55
00:03:35,640 --> 00:03:39,540
And in this case, no gravity is set. If we specify gravity equals center,

56
00:03:39,540 --> 00:03:43,250
then it will center the content within the text view. Vertically it can't move,

57
00:03:43,250 --> 00:03:46,960
'because it's already centered, but horizontally it does shift over to be in

58
00:03:46,960 --> 00:03:50,570
the middle. Instead of this. If we specify layout gravity equals center,

59
00:03:50,570 --> 00:03:53,540
that means to center horizontally and vertically within the parent.

60
00:03:53,540 --> 00:03:57,160
So we grab the whole child text view and we move it into the center.

61
00:03:57,160 --> 00:04:00,440
Now it can't be centered horizontally, because it already takes up the max width

62
00:04:00,440 --> 00:04:03,530
of the parent. If we really want to move the content to the middle,

63
00:04:03,530 --> 00:04:07,600
then we should specify wrap content on this text view, so that it can be

64
00:04:07,600 --> 00:04:11,350
moved to the center with this attribute. You can also specify padding and

65
00:04:11,350 --> 00:04:15,710
margin on views. For example, if you added padding on this text view,

66
00:04:15,710 --> 00:04:19,750
then it would shift the content inside by x amount on all sides.

67
00:04:19,750 --> 00:04:23,390
If you specify layout margin to be x, then remember that the parent is

68
00:04:23,390 --> 00:04:27,320
the one who will be interpreting this layout ground. In this case,

69
00:04:27,320 --> 00:04:31,240
it adds a margin of x all around the text view. The text view is only this size.

70
00:04:32,260 --> 00:04:35,280
When you render both of these, they would visually look the same.

71
00:04:35,280 --> 00:04:37,690
Here's one case where it could matter. If this was a button and

72
00:04:37,690 --> 00:04:41,740
you pressed it, there could be a gray background here showing. In some cases you

73
00:04:41,740 --> 00:04:47,010
may want padding or margin or both. All views have a visibility property. For

74
00:04:47,010 --> 00:04:50,020
this image view, it can be visible, invisible, or gone.

75
00:04:50,020 --> 00:04:53,390
If it's invisible then it's not shown, but there's still a place holder for

76
00:04:53,390 --> 00:04:56,830
it, we still have to go and measure the size of it. If it's gone,

77
00:04:56,830 --> 00:04:59,920
then it's not even in the layout. It's as if it didn't exist in the XML.

78
00:04:59,920 --> 00:05:04,490
You can also toggle the visibility of a view dynamically during runtime.

79
00:05:04,490 --> 00:05:08,680
In the java doc, you can find all the possible XML attributes for that class.

80
00:05:08,680 --> 00:05:12,740
It also shows inherited XML attributes, for example, from the view class.

81
00:05:12,740 --> 00:05:16,430
For this image view, and then it shows the corresponding Java methods for

82
00:05:16,430 --> 00:05:20,310
those attributes. Now as a briefer for [UNKNOWN] basics to help us get started,

83
00:05:20,310 --> 00:05:22,250
but definitely check out the developer site for

84
00:05:22,250 --> 00:05:26,670
more details later. Much like the real world, if you were working with a team to

85
00:05:26,670 --> 00:05:30,660
build an Android app, you would start by implementing the wire frames first.

86
00:05:30,660 --> 00:05:33,920
This has a correct flow for how the user will interact with the app. But

87
00:05:33,920 --> 00:05:37,780
it doesn't have the final visual look and feel yet. We'll build this up step by

88
00:05:37,780 --> 00:05:42,030
step, starting with the main activity then we'll move on to the detail activity

89
00:05:42,030 --> 00:05:46,630
and then later build up the tablet UI. Then we'll receive a set of visual marks

90
00:05:46,630 --> 00:05:50,780
red lines and assets, all of this will help us build a pixel perfect layout

